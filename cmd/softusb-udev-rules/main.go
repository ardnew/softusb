// Command softusb-udev-rules generates udev rules for USB device access.
//
// This tool creates udev rules that grant user access to USB devices,
// eliminating the need to run applications as root.
//
// # Usage
//
//	softusb-udev-rules [flags]
//
// # Flags
//
//	-o file      Output file path (default: stdout)
//	-vid id      Filter by USB Vendor ID (hex)
//	-pid id      Filter by USB Product ID (hex)
//	-class id    Filter by USB device class (hex)
//	-group name  Group to grant access (default: plugdev)
//	-mode mode   File permissions (default: 0660)
//	-all         Generate rules for all USB devices
//	-hid         Generate rules for all HID devices
//
// # Examples
//
// Generate rules for a specific device:
//
//	softusb-udev-rules -vid 046d -pid c52b -o /etc/udev/rules.d/99-logitech.rules
//
// Generate rules for all HID devices:
//
//	softusb-udev-rules -hid -o /etc/udev/rules.d/99-hid.rules
//
// Generate rules for all USB devices (not recommended for production):
//
//	softusb-udev-rules -all -o /etc/udev/rules.d/99-usb.rules
//
// After creating rules, reload udev:
//
//	sudo udevadm control --reload-rules
//	sudo udevadm trigger
package main

import (
	"flag"
	"fmt"
	"os"
	"strings"
)

var (
	outputFile  = flag.String("o", "", "Output file path (default: stdout)")
	vendorID    = flag.String("vid", "", "Filter by Vendor ID (hex)")
	productID   = flag.String("pid", "", "Filter by Product ID (hex)")
	deviceClass = flag.String("class", "", "Filter by device class (hex)")
	groupName   = flag.String("group", "plugdev", "Group to grant access")
	fileMode    = flag.String("mode", "0660", "File permissions")
	allDevices  = flag.Bool("all", false, "Generate rules for all USB devices")
	hidDevices  = flag.Bool("hid", false, "Generate rules for all HID devices")
)

func main() {
	flag.Parse()

	if !*allDevices && !*hidDevices && *vendorID == "" && *deviceClass == "" {
		fmt.Fprintln(os.Stderr, "Error: Must specify at least one of: -all, -hid, -vid, or -class")
		fmt.Fprintln(os.Stderr, "Use -help for usage information")
		os.Exit(1)
	}

	// Header
	var rules []string
	rules = append(rules, "# Generated by softusb-udev-rules")
	rules = append(rules, "# https://github.com/ardnew/softusb")
	rules = append(rules, "")

	if *allDevices {
		rules = append(rules, generateAllUSBRule())
	} else if *hidDevices {
		rules = append(rules, generateHIDRule())
	} else {
		rules = append(rules, generateSpecificRule())
	}

	output := strings.Join(rules, "\n") + "\n"

	if *outputFile == "" {
		fmt.Print(output)
	} else {
		if err := os.WriteFile(*outputFile, []byte(output), 0o644); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing file: %v\n", err)
			os.Exit(1)
		}
		fmt.Fprintf(os.Stderr, "Rules written to %s\n", *outputFile)
		fmt.Fprintln(os.Stderr, "")
		fmt.Fprintln(os.Stderr, "To apply the rules, run:")
		fmt.Fprintln(os.Stderr, "  sudo udevadm control --reload-rules")
		fmt.Fprintln(os.Stderr, "  sudo udevadm trigger")
	}
}

// generateAllUSBRule generates a rule for all USB devices.
func generateAllUSBRule() string {
	return fmt.Sprintf(
		`# Allow access to all USB devices
SUBSYSTEM=="usb", MODE="%s", GROUP="%s"`,
		*fileMode, *groupName,
	)
}

// generateHIDRule generates rules for all HID devices.
func generateHIDRule() string {
	return fmt.Sprintf(
		`# Allow access to all USB HID devices
SUBSYSTEM=="usb", ATTR{bInterfaceClass}=="03", MODE="%s", GROUP="%s"
# Also allow access to the raw USB device for HID interfaces
SUBSYSTEM=="usb", DRIVER=="usbhid", MODE="%s", GROUP="%s"`,
		*fileMode, *groupName,
		*fileMode, *groupName,
	)
}

// generateSpecificRule generates a rule for specific devices.
func generateSpecificRule() string {
	var conditions []string
	conditions = append(conditions, `SUBSYSTEM=="usb"`)

	if *vendorID != "" {
		// Normalize to 4 hex digits
		vid := strings.ToLower(strings.TrimPrefix(*vendorID, "0x"))
		vid = fmt.Sprintf("%04s", vid)
		conditions = append(conditions, fmt.Sprintf(`ATTR{idVendor}=="%s"`, vid))
	}

	if *productID != "" {
		// Normalize to 4 hex digits
		pid := strings.ToLower(strings.TrimPrefix(*productID, "0x"))
		pid = fmt.Sprintf("%04s", pid)
		conditions = append(conditions, fmt.Sprintf(`ATTR{idProduct}=="%s"`, pid))
	}

	if *deviceClass != "" {
		// Normalize to 2 hex digits
		class := strings.ToLower(strings.TrimPrefix(*deviceClass, "0x"))
		class = fmt.Sprintf("%02s", class)
		conditions = append(conditions, fmt.Sprintf(`ATTR{bDeviceClass}=="%s"`, class))
	}

	conditions = append(conditions, fmt.Sprintf(`MODE="%s"`, *fileMode))
	conditions = append(conditions, fmt.Sprintf(`GROUP="%s"`, *groupName))

	comment := "# Allow access to"
	if *vendorID != "" {
		comment += fmt.Sprintf(" VID=%s", *vendorID)
	}
	if *productID != "" {
		comment += fmt.Sprintf(" PID=%s", *productID)
	}
	if *deviceClass != "" {
		comment += fmt.Sprintf(" Class=%s", *deviceClass)
	}

	return comment + "\n" + strings.Join(conditions, ", ")
}
